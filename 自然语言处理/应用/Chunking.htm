<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=OneNote.File>
<meta name=Generator content="Microsoft OneNote 15">
<link id=Main-File rel=Main-File href=Chunking.htm>
<link rel=File-List href="Chunking.files/filelist.xml">
</head>

<body lang=zh-CN style='font-family:微软雅黑;font-size:12.0pt'>

<div style='direction:ltr;border-width:100%'>

<div style='direction:ltr;margin-top:0in;margin-left:0in;width:12.1368in'>

<div style='direction:ltr;margin-top:0in;margin-left:0in;width:1.6118in'>

<p style='margin:0in;font-size:20.0pt'><span style='font-family:微软雅黑'
lang=en-US>C</span><span style='font-family:"Calibri Light"' lang=zh-CN>hunking</span></p>

</div>

<div style='direction:ltr;margin-top:.0423in;margin-left:0in;width:12.1368in'><nobr><img
src="Chunking.files/image001.png" width=1748 height=1440
alt="Level 1 : Fixed Size Chunking&#13;&#10;This is the most crude and simplest method of segmenting the text. It breaks down the text into chunks of a specified number of characters, regardless of their content or structure.&#13;&#10;Langchain and llamaindex&nbsp;framework offer&nbsp;﷟HYPERLINK &quot;https://python.langchain.com/docs/modules/data_connection/document_transformers/character_text_splitter&quot;CharacterTextSplitter&nbsp;and&nbsp;﷟HYPERLINK &quot;https://docs.llamaindex.ai/en/stable/api/llama_index.node_parser.SentenceSplitter.html&quot;SentenceSplitter&nbsp;(default to spliting on sentences) classes for this chunking technique. A few concepts to remember -&#13;&#10;How the text is split: by single character&#13;&#10;How the chunk size is measured:&nbsp;by number of characters&#13;&#10;chunk_size:&nbsp;the number of characters in the chunks&#13;&#10;chunk_overlap:&nbsp;the number of characters that are being overlap in sequential chunks. keep duplicate data across chunks&#13;&#10;separator: character(s) on which the text would be split on (default “”)&#13;&#10;&#13;&#10;Level 2: Recursive Chunking&#13;&#10;While Fixed size chunking is easier to implement, it doesn’t consider the structure of text. Recursive chunking offers an alternative.&#13;&#10;In this method, we divide the text into smaller chunk in a hierarchical and iterative manner using a set of separators. If the initial attempt at splitting the text doesn’t produce chunks of the desired size, the method recursively calls itself on the resulting chunks with a different separator until the desired chunk size is achieved.&#13;&#10;Langchain framework offers&nbsp;﷟HYPERLINK &quot;https://python.langchain.com/docs/modules/data_connection/document_transformers/recursive_text_splitter&quot;RecursiveCharacterTextSplitter&nbsp;class, which splits text using&nbsp;﷟HYPERLINK &quot;https://github.com/langchain-ai/langchain/blob/9ef2feb6747f5a69d186bd623b569ad722829a5e/libs/langchain/langchain/text_splitter.py#L842&quot;default separators&nbsp;(“\n\n”, “\n”, “ “,””)&#13;&#10;&#13;&#10;Level 3 : Document Based Chunking&#13;&#10;In this chunking method, we split a document based on its inherent structure. This approach considers the flow and structure of content but may not be as effective documents lacking clear structure.&#13;&#10;For instance, a legal document might be chunked by individual charges, with each charge treated as a chunk. This method maintains the document's structural integrity and ensures that no important legal context is lost.&nbsp;&#13;&#10;类似一个章节，或一个小节等。&#13;&#10;&#13;&#10;Level 4: Semantic Chunking&#13;&#10;All above three levels deals with content and structure of documents and necessitate maintaining constant value of chunk size. This chunking method aims to extract semantic meaning from embeddings and then assess the semantic relationship between these chunks. The core idea is to keep together chunks that are semantic similar.&#13;&#10;2025年8月1日 星期五&#13;&#10;10:45&#13;&#10;"><br>
<img src="Chunking.files/image002.png" width=1748 height=1440
alt="All above three levels deals with content and structure of documents and necessitate maintaining constant value of chunk size. This chunking method aims to extract semantic meaning from embeddings and then assess the semantic relationship between these chunks. The core idea is to keep together chunks that are semantic similar.&#13;&#10;&#13;&#10;Level 5: Agentic Chunking&#13;&#10;This chunking strategy explore the possibility to use LLM to determine how much and what text should be included in a chunk based on the context.&#13;&#10;To generate initial chunks, it uses&nbsp;﷟HYPERLINK &quot;https://arxiv.org/pdf/2312.06648.pdf&quot;concept of Propositions based on paperthat extracts stand alone statements from a raw piece of text. Langchain provides&nbsp;﷟HYPERLINK &quot;https://templates.langchain.com/new?integration_name=propositional-retrieval&quot;propositional-retrieval template&nbsp;to implement this.&#13;&#10;After generating propositions, these are being feed to LLM-based agent. This agent determine whether a proposition should be included in an existing chunk or if a new chunk should be created.&#13;&#10;&#13;&#10;&#13;&#10;Introducing Contextual Retrieval&#13;&#10;The context conundrum in traditional RAG&#13;&#10;In traditional RAG, documents are typically split into smaller chunks for efficient retrieval. While this approach works well for many applications, it can lead to problems when individual chunks lack sufficient context.&#13;&#10;&#13;&#10;For example, imagine you had a collection of financial information (say, U.S. SEC filings) embedded in your knowledge base, and you received the following question: &quot;What was the revenue growth for ACME Corp in Q2 2023?&quot;&#13;&#10;&#13;&#10;A relevant chunk might contain the text: &quot;The company's revenue grew by 3% over the previous quarter.&quot; However, this chunk on its own doesn't specify which company it's referring to or the relevant time period, making it difficult to retrieve the right information or use the information effectively.&#13;&#10;chunk中没有显式地提到ACME公司，而是The company，因此需要加入额外的上下文信息，这个信息可以用LLM提取，&#13;&#10;未命名图片.jpg 计算机生成了可选文字:&#10;&lt;document&gt;&#10;{{WHOLE_DOCUMENT}}&#10;&lt;/document&gt;&#10;HereisthechunkwewanttoSituatewithinthewholedocument&#10;&lt;chunk&gt;&#10;{{CHUNK_CONTENT}}&#10;&lt;/chunk&gt;&#10;Pleasegiveashortsuccinctcontextt0situatethischunkwithintheoveralldocumentforthe&#10;purposesOfimprovingsearchretrievalOfthechunk.AnsweronlyWiththesuccinctcontextandnothing&#10;else.&#13;&#10;"><br>
<img src="Chunking.files/image003.png" width=1748 height=141
alt="未命名图片.jpg 计算机生成了可选文字:&#10;&lt;document&gt;&#10;{{WHOLE_DOCUMENT}}&#10;&lt;/document&gt;&#10;HereisthechunkwewanttoSituatewithinthewholedocument&#10;&lt;chunk&gt;&#10;{{CHUNK_CONTENT}}&#10;&lt;/chunk&gt;&#10;Pleasegiveashortsuccinctcontextt0situatethischunkwithintheoveralldocumentforthe&#10;purposesOfimprovingsearchretrievalOfthechunk.AnsweronlyWiththesuccinctcontextandnothing&#10;else.&#13;&#10;&#13;&#10;"><br>
</nobr></div>

</div>

</div>

<div>

<p style='margin:0in'>&nbsp;</p>

<p style='text-align:left;margin:0in;font-family:Arial;font-size:9pt;
color:#969696;direction:ltr'>已使用 OneNote 创建。</p>

</div>

</body>

</html>
